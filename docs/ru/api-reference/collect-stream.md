# CollectStream

```js
const stream = vk.collect.<method>({...});
```

Список необязательных параметров которые будут использоваться

| Свойство      | Тип    | Описание                                       | По умолчанию |
|---------------|--------|------------------------------------------------|--------------|
| offset        | number | Смещение                                       | 0            |
| count         | number | Общее количество данных которые нужно получить | null         |
| parallelCount | number | Количество параллельных запросов в execute     | 25           |

Если `parallelCount` равен `1` в таком случае запросы будут без `execute`

Работает так же с сервисным токеном, но без `execute` (то есть по одному прямому запросу за раз)

Данные можно получить двумя способами

## stream
Тут достаточно всё просто, вешаем обработчик и данные будут постепенно приходить

Плюс данного подхода в том что мы получаем данные по мере их получения

```js
stream.on('error', console.error);

stream.on('data', payload => {...});

stream.on('end', () => {
	console.log('Все данные получены');
});
```

В `payload` содержатся следующие свойства

| Свойство | Тип      | Описание                              |
|----------|----------|---------------------------------------|
| total    | number   | Сколько нужно получить данных         |
| percent  | number   | На сколько процентов выполнена задача |
| received | number   | Сколько уже получено данных           |
| items    | Object[] | Набор данных                          |

## promise
> Обратите внимание

> Если вы используете потоковый режим, не используйте `Promise` для того что бы узнать когда завершиться процесс получения данных, так как он будет сохранять данные для передачи в `Promise`

С `Promise` всё проще, но стоит учитывать что данные будут накапливаться в памяти пока не будут получены все или не появится ошибка. Если на сервере будет недостаточно памяти, то это вызовет переполнение стака

```js
stream.then((items) => {
	// ...
});

// OR

async function run() {
	const items = await stream;

	// ...
}

run().catch(console.error);
```

Так же возвращаемый `Promise` будет всегда уникальным при вызове `stream.then`
